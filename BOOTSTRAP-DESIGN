PARTCIPANTS:
REMOTE (R:) - Has secrets to give to enclave once it is sure enclave is secure
ENCLAVE (E:) - Potentially secure code that seeks to acquire secrets from enclave
               for whom it knows the public key and network address of.
USER (U:) - Starts enclave code and proxies communication for it; can see 
            code initially loaded into enclave!


U: Load enclave bootstrap code and get einittoken for enclave code
U: Launch enclave code using einittoken and enter event loop to handle
   requests from the enclave
E: Raise SENDTO to remote to request secrets
U: Gets send request and forwards it to REMOTE
E: Raise RECVFROM request from remote
U: Blocks in recvfrom() waiting for response
R: Sends diffie hellman nonce to enclave, requesting a quote from it
U: Receives message from remote, raises RECVFROM_RESP in enclave with nonce
E: Raises QUOTE_REQ to user
U: Constructs targetinfo for quoting enclave, raises REPORT_REQ to enclave
E: generates report using received nonce, generated public key for dest, stores
   private key. Raises REPORT_RESP to user
U: Calls quoting enclave to sign report, raises QUOTE_RESP to user
E: raises SENDTO to send signed quote to REMOTE along with nonces to remote
U: calls sendto() to send quote to remote
E: raises RECVFROM to receive //secrets//
U: calls recvfrom from remote
R: Receives the intel-signed report with nonces. Check that included
   MrEnclave, MrSigner, and quoted signature are correct. Correctness
   indicates secure communiction with the provided enclave
   - The fact that it includes the original nonce/public key means that this 
     isn't a replayed exchange - we're talking to someone live
   - The report includes a hash code and signature of the person 
     talking to us, along with their public key, purportedly an 
     encalve with hash MrEnclave signed by MrSigner
   - The quoted report says that intel attests that the supplied report was 
     generated by an intel processor running an enclave initialized with that
     hash.
R: Encrypts secret with enclave's enclosed public key and sends secrets.
U: Receives encrypted secrets and raises RECVFROM_RESP in enclave
E: Copies in secrets, decrypts them using the temporary key, and checks that 
   they are signed with the appropriate public key.

XXX PGB Somewhere in here, we probably actually exchange a real secret key
using the exchanged diffie-hellman keys, so we don't have to do public key
encryption the whole time. Figure out how this who process actually ties into 
a real TLS communication setup. 
